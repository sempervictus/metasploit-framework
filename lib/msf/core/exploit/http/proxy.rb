# -*- coding: binary -*-
require 'rex/service_manager'
require 'rex/proto/http/proxy'
require 'msf/core/exploit/http/server'

###
# This module provides an HTTP proxy server
# By default the proxy functions in MITM mode
# forwarding all requests along the switchboard.
# Settings RHOST, RPORT, and VHOST will restrict
# the proxy conenctions to those settings making
# it an "http-connect" proxy.
##

module Msf
module Exploit::Remote::HttpServer::Proxy

  include Msf::Exploit::Remote::HttpClient
  include Msf::Exploit::Remote::HttpServer

  def initialize(info = {})
    super(
      'Actions'     =>
        [
          [ 'WebServer' ]
        ],
      'PassiveActions' =>
        [
          'WebServer'
        ],
      'DefaultAction'  => 'WebServer'
    )

    # We handle these differently depending on how we use the proxy
    deregister_options('RHOST', 'RPORT')
    register_options(
      [
        OptString.new('VHOST', [ true, "HTTP virtual host for proxy requests", "*" ]),
        OptString.new('RHOST', [ false, "Set this to direct all traffic to a specific host"]),
        OptInt.new('RPORT', [ false, "Set this in conjunction with RHOST to direct all traffic to specific port"]),
        OptString.new('URIPATH', [ true,  "The base URI at which the proxy will begin to forward requests", '/']),
      ], Exploit::Remote::HttpServer::Proxy
    )
    register_advanced_options(
      [
        OptBool.new('HTTP::proxy::rewrite_proxy_headers', [true, 'Rewrite proxy-specific headers from client', true]),
        OptInt.new('HTTP::proxy::redirect_limit', [false, 'Maximum number of redirects for proxied client request', 0]),
      ], Exploit::Remote::HttpServer::Proxy
    )
  end

  def start_service(opts = {})

    check_dependencies

    comm = datastore['ListenerComm']
    if (comm.to_s == "local")
      comm = ::Rex::Socket::Comm::Local
    else
      comm = nil
    end

    # Default the server host and port to what is required by the mixin.
    opts = {
      'ServerHost' => datastore['SRVHOST'],
      'ServerPort' => datastore['SRVPORT'],
      'Comm'       => comm
    }.update(opts)

    # Start a new HTTP server service.
    self.service = Rex::ServiceManager.start(
      Rex::Proto::Http::Proxy,
      opts['ServerPort'].to_i,
      opts['ServerHost'],
      datastore['SSL'],
      {
        'Msf'        => framework,
        'MsfExploit' => self,
      },
      opts['Comm'],
      datastore['SSLCert'],
      datastore['Proxies'],
      datastore['HTTP::proxy::rewrite_proxy_headers'],
      datastore['RHOST'],
      datastore['RPORT']
    )

    # Add request and response hooks
    service.req_handler = Proc.new { |cli,request|
      proxy_action_request(cli,request)
    }

    service.res_handler = Proc.new { |cli,response|
      proxy_action_response(cli,response)
    }
    proto = (datastore["SSL"] ? "https" : "http")

    print_status("Using URL: #{proto}://#{opts['ServerHost']}:#{opts['ServerPort']}/")

    if (opts['ServerHost'] == '0.0.0.0')
      print_status(" Local IP: #{proto}://#{Rex::Socket.source_address('1.2.3.4')}:#{opts['ServerPort']}/")
    end

  end

  # Overload this to work wtih initial request
  def proxy_action_request(cli, request)
    nil # MITM or logging can go here
  end

  # Overload this to work with response
  def proxy_action_response(cli, response)
    nil
  end

  # Rewrite referer for HTTP request as needed
  def set_referer(cli,request)
    request.headers.select {|k,v| k =~ /referer/i}.each do |key, ref|
      substr = ref.scan(/http.*\:\/\/(.*?)\//).flatten.first
      newsub = datastore['VHOST'] unless datastore['VHOST'].strip == '*'
      newsub ||= datastore['RHOST']
      # Only pass non-default ports
      if datastore['RPORT'] != 0
        case datastore['RPORT']
        when 443
          newsub << ":#{datastore['RPORT']}" unless ref.match(/https/i)
        when 80
          newsub << ":#{datastore['RPORT']}" unless ref.match(/http\:/i)
        else
          newsub << ":#{datastore['RPORT']}" if newsub
        end
        headers[key] = ref.sub(substr,newsub)
      end
    end
  end

end

end
